9d8
< 
13d11
<          type(sub_space), allocatable       :: active_space(:)
23,26c21
<          type(dist_cmplx_mat)               :: R
<          double precision, allocatable      :: T1(:)
<          complex(8), allocatable            :: Rval(:)
<          type(dist_cmplx_mat)               :: T2
---
>          type(dist_cmplx_mat), allocatable  :: S(:)
31d25
<          logical                            :: make_Rmat=.false.
42,44d35
<          procedure   ::  make_R => make_R_H
<          procedure   ::  make_rot
<          procedure   ::  rot_rho
46d36
<          procedure   ::  set_sph_dipolar
60,293d49
< 
<         subroutine make_R_H(this,sys,phondy,step_min,mult_fact,max_ener)
<         use mpi
<         use mpi_utils
<         use blacs_utils
<         use scalapack_diag_simm
<         use scalapack_diag_asimm
<         use lapack_diag_asimm
<         use lapack_inverse
<         use units_parms 
<         use atoms_class
<         use phonons_class
<         implicit none
<         class(spins_hilbert)         :: this
<         class(brillouin)             :: phondy
<         class(atoms_group)           :: sys
<         type(dist_cmplx_mat)         :: AA,BB
<         type(dist_dbl_mat)           :: R0
<         double precision             :: Gf,DEner,step_min
<         double precision             :: val,norm,max_ener
<         complex(8),allocatable       :: Vii(:)
<         integer                      :: ph,bn,ii,jj,l,l2,size_block,i1,ii_1,i
<         integer                      :: k,ia,ib,ka,kb
<         integer                      :: t1,t2,rate,indxl2g
<         integer                      :: mult_fact,s,t
< 
<          if(.not.this%make_Heig)then          
<           write(*,*) 'Warning, open system symulation in the Sz basis', &
<                      'is not implemented yet'
<           return
<          endif
< 
<          if(mpi_id.eq.0)then
<           call system_clock(t1,rate)
<           write(*,*) '   Building R matrix'
<           flush(6)
<          endif
< 
<          call R0%set(this%Hdim,this%Hdim,NB,MB)
<          R0%mat=(0.0d0,0.0d0)
< 
<          call this%T2%set(this%Hdim,this%Hdim,NB,MB)
<          this%T2%mat=(0.0d0,0.0d0)
< 
<          allocate(this%T1(this%Hdim))
<          allocate(Vii(this%Hdim))
< 
<          call AA%set(this%Hdim,this%Hdim,NB,MB)
< 
<          do ph=1,phondy%ntot
< 
<       ! Check for Ph lifetime           
< 
<           if(.not.allocated(phondy%list(ph)%width))then
<            allocate(phondy%list(ph)%width(size(phondy%list(ph)%freq),1))
<            phondy%list(ph)%width=smear
<           endif
< 
<           do bn=1,size(phondy%list(ph)%freq)
< 
<       ! Build SPH per phonon
< 
<            if (ph.eq.1 .and. bn.le.3) cycle
<            if (phondy%list(ph)%freq(bn).gt.max_ener) cycle
< 
<            call this%SPH%cart2brill(this%rcell,sys,phondy,ph,bn)
<        
<       ! Make Vij 
< 
<            AA%mat=(0.0d0,0.0d0)
< 
<            do ii=1,size(AA%mat,1)
<             do jj=1,size(AA%mat,2)
<  
<              l=indxl2g(ii,1,myrow,0,nprow)
<              l2=indxl2g(jj,1,mycol,0,npcol)
<            
<              AA%mat(ii,jj)=this%get_Hij(this%SPH,l,l2)
< 
<             enddo ! l2
<            enddo ! l
< 
< 
<       ! Rotate Vij
< 
<            if(this%ntot.gt.1)then
<             call this%to_kbasis(AA)
<            endif
< 
<            if(this%make_Heig)then
<             call this%to_eigenbasis(AA)
<            endif
<           
<            do l=1,this%Hdim
<             call pzelget('A',' ',Vii(l),AA%mat,l,l,AA%desc)
<            enddo
< 
<       ! Make Rij
< 
<            do ii=1,size(R0%mat,1)
<             do jj=1,size(R0%mat,2)
< 
<              l=indxl2g(ii,1,myrow,0,nprow)
<              l2=indxl2g(jj,1,mycol,0,npcol)
< 
<              do ii_1=1,this%ntot
<               if(l.le.this%kblc(ii_1+1))then
<                ka=ii_1
<                ia=l-this%kblc(ii_1)
<                exit
<               endif        
<              enddo
< 
<              do ii_1=1,this%ntot
<               if(l2.le.this%kblc(ii_1+1))then
<                kb=ii_1
<                ib=l2-this%kblc(ii_1)
<                exit
<               endif
<              enddo
< 
<              DEner=this%Ener(ka)%v(ia)-this%Ener(kb)%v(ib)-phondy%list(ph)%Freq(bn)
<              Gf=bose(temp(1),phondy%list(ph)%Freq(bn))*deltaL(DEner,phondy%list(ph)%width(bn,1))
< 
<              DEner=this%Ener(ka)%v(ia)-this%Ener(kb)%v(ib)+phondy%list(ph)%Freq(bn)
<              Gf=Gf+(bose(temp(1),phondy%list(ph)%Freq(bn))+1)*deltaL(DEner,phondy%list(ph)%width(bn,1))
<              
<              R0%mat(ii,jj)=R0%mat(ii,jj)+AA%mat(ii,jj)*conjg(AA%mat(ii,jj))*Gf
< 
<             enddo
<            enddo
< 
<       ! make T2 
< 
<            do ii=1,size(this%T2%mat,1)
<             do jj=1,size(this%T2%mat,2)
< 
<              l=indxl2g(ii,1,myrow,0,nprow)
<              l2=indxl2g(jj,1,mycol,0,npcol)
< 
<              DEner=phondy%list(ph)%Freq(bn)
<              Gf=bose(temp(1),phondy%list(ph)%Freq(bn))*deltaL(DEner,phondy%list(ph)%width(bn,1))
< 
<              DEner=phondy%list(ph)%Freq(bn)
<              Gf=Gf+(bose(temp(1),phondy%list(ph)%Freq(bn))+1)*deltaL(DEner,phondy%list(ph)%width(bn,1))
< 
<              this%T2%mat(ii,jj)=this%T2%mat(ii,jj)+(2*Vii(l)*Vii(l2)-Vii(l)*Vii(l)-Vii(l2)*Vii(l2))*Gf
< 
<             enddo
<            enddo
< 
<           enddo
<          enddo
< 
<          R0%mat=4*pi*pi*R0%mat/hplank
<          this%T2%mat=4*pi*pi*this%T2%mat/hplank
< 
<          do l=1,this%Hdim
<           norm=0.0d0
<           do l2=1,this%Hdim         
<            if(l.ne.l2)then  
<             call pdelget('A',' ',val,R0%mat,l2,l,R0%desc)
<             norm=norm-val
<            endif
<           enddo
<           this%T1(l)=norm
<           call pdelset(R0%mat,l,l,R0%desc,norm)
<          enddo
< 
<          if(mpi_id.eq.0)then
<           write(*,*) '           T1 (ps)'
<           do i=1,this%Hdim
<            write(*,*) i,-1.0d0/this%T1(i)
<           enddo
<          endif
< 
<       ! Compute correlation propagator
<        
<          do ii=1,size(this%T2%mat,1)
<           do jj=1,size(this%T2%mat,2)
< 
<            l=indxl2g(ii,1,myrow,0,nprow)
<            l2=indxl2g(jj,1,mycol,0,npcol)
< 
<            this%T2%mat(ii,jj)=this%T2%mat(ii,jj)+ &
<                                    0.50d0*(this%T1(l)+this%T1(l2))
< 
<            this%T2%mat(ii,jj)=exp(step_min*mult_fact*this%T2%mat(ii,jj))
< 
<           enddo
<          enddo
< 
<       ! Diag Rij ! check routine
< 
<          AA%mat=(0.0d0,0.0d0)
<          allocate(this%Rval(this%Hdim))
< 
<          call BB%set(this%Hdim,this%Hdim,NB,MB)
<          BB%mat=(0.0d0,0.0d0)
< 
<          call pddiag2(this%Hdim,R0,this%Rval,AA,BB)
< 
<       ! Build Pop Propagator R= R exp(Rval) R^{\cross}
< 
<          this%Rval=exp(step_min*mult_fact*this%Rval)
< 
<          call this%R%set(this%Hdim,this%Hdim,NB,MB)
<          this%R%mat=(0.0d0,0.0d0)
< 
<          do ii=1,size(AA%mat,1)
<           do jj=1,size(AA%mat,2)
<            l=indxl2g(jj,1,myrow,0,nprow)
<            AA%mat(ii,jj)=AA%mat(ii,jj)*this%Rval(l)
<           enddo
<          enddo
< 
<          call pzgemm('N','C',this%Hdim,this%Hdim,this%Hdim,&
<                      (1.0d0,0.0d0),AA%mat,1,1,AA%desc,BB%mat,&
<                      1,1,BB%desc,(0.0d0,0.0d0),this%R%mat,1,1,this%R%desc)
< 
<          call AA%dealloc()
<          call BB%dealloc()
<          call R0%dealloc()
< 
<          if(mpi_id.eq.0)then
<           call system_clock(t2)
<           write(*,*) '       ... Done in ',real(t2-t1)/real(rate),'s'
<           flush(6)
<          endif
< 
<         return
<         end subroutine make_R_H
< 
< 
302d57
<         type(dist_cmplx_vec)         :: pop,pop_new
304d58
<         complex(8)                   :: val
318c72
<           if(this%s2print.gt.0) call this%dump_M(0,time)
---
>           call this%dump_M(0,time)
323,329d76
<          if(this%make_Rmat)then
<           call pop%set(this%Hdim,NB)
<           pop%vec=(0.0d0,0.0d0)
<           call pop_new%set(this%Hdim,NB)
<           pop_new%vec=(0.0d0,0.0d0)
<          endif
< 
358c105
<              
---
> 
365,399d111
<            if(this%make_Rmat)then
< 
<             ! propagate populations
< 
<             do l=1,this%Hdim
<              call pzelget('A',' ',val,this%rho%mat,l,l,this%rho%desc)
<              call pzelset(pop%vec,l,1,pop%desc,val)
<             enddo
< 
<             call pzgemv('N',this%Hdim,this%Hdim,&
<                         1.0d0,this%R%mat,1,1,this%R%desc,pop%vec,1,1,pop%desc,&
<                         1,0.0d0,pop_new%vec,1,1,pop_new%desc,1)
< 
<             do l=1,this%Hdim
<              call pzelget('A',' ',val,pop_new%vec,l,1,pop_new%desc)
<              call pzelset(this%rho%mat,l,l,this%rho%desc,val)
<             enddo   
<         
<             ! propagate correlations
< 
<             do ii=1,size(this%rho%mat,1)
<              do jj=1,size(this%rho%mat,2)
< 
<               l=indxl2g(ii,1,myrow,0,nprow)
<               v=indxl2g(jj,1,mycol,0,npcol)
< 
<               if(l.ne.v)then
<                this%rho%mat(ii,jj)=this%T2%mat(ii,jj)*this%rho%mat(ii,jj)
<               endif
< 
<              enddo
<             enddo
< 
<            endif ! end Rmat if
< 
401,405d112
< 
<            if(this%make_Rmat)then
<             write(*,*) 'Warning, open system symulation in the Szbasis',  &
<                        'is not implemented yet'
<            endif
407c114
<            call AA%set(this%Hdim,this%Hdim,NB,MB)
---
>             call AA%set(this%Hdim,this%Hdim,1,1)
409,410c116,117
<            do kp1=1,this%ntot
<             do kp2=1,this%ntot
---
>             do kp1=1,this%ntot
>              do kp2=1,this%ntot
412,421c119,128
<              block1=this%kblc(kp1+1)-this%kblc(kp1)
<              block2=this%kblc(kp2+1)-this%kblc(kp2)
<              i1=this%kblc(kp1)+1
<              j1=this%kblc(kp1)+1
<              i2=this%kblc(kp2)+1
<              j2=this%kblc(kp2)+1
< 
<              call pzgemm('N','N',block1,block2,block1,&
<                          (1.0d0,0.0d0),this%U(kp1)%mat,1,1,this%U(kp1)%desc,this%rho%mat,&
<                          i1,j2,this%rho%desc,(0.0d0,0.0d0),AA%mat,i1,j2,AA%desc)
---
>               block1=this%kblc(kp1+1)-this%kblc(kp1)
>               block2=this%kblc(kp2+1)-this%kblc(kp2)
>               i1=this%kblc(kp1)+1
>               j1=this%kblc(kp1)+1
>               i2=this%kblc(kp2)+1
>               j2=this%kblc(kp2)+1
> 
>               call pzgemm('N','N',block1,block2,block1,&
>                           (1.0d0,0.0d0),this%U(kp1)%mat,1,1,this%U(kp1)%desc,this%rho%mat,&
>                           i1,j2,this%rho%desc,(0.0d0,0.0d0),AA%mat,i1,j2,AA%desc)
423a131
>              enddo
425d132
<            enddo
427,428c134,135
<            do kp1=1,this%ntot
<             do kp2=1,this%ntot
---
>             do kp1=1,this%ntot
>              do kp2=1,this%ntot
430,439c137,146
<              block1=this%kblc(kp1+1)-this%kblc(kp1)
<              block2=this%kblc(kp2+1)-this%kblc(kp2)
<              i1=this%kblc(kp1)+1
<              j1=this%kblc(kp1)+1
<              i2=this%kblc(kp2)+1
<              j2=this%kblc(kp2)+1
< 
<              call pzgemm('N','C',block1,block2,block2,&
<                          (1.0d0,0.0d0),AA%mat,i1,j2,AA%desc,this%U(kp2)%mat,1,1,this%U(kp2)%desc,&
<                          (0.0d0,0.0d0),this%rho%mat,i1,j2,this%rho%desc) 
---
>               block1=this%kblc(kp1+1)-this%kblc(kp1)
>               block2=this%kblc(kp2+1)-this%kblc(kp2)
>               i1=this%kblc(kp1)+1
>               j1=this%kblc(kp1)+1
>               i2=this%kblc(kp2)+1
>               j2=this%kblc(kp2)+1
> 
>               call pzgemm('N','C',block1,block2,block2,&
>                           (1.0d0,0.0d0),AA%mat,i1,j2,AA%desc,this%U(kp2)%mat,1,1,this%U(kp2)%desc,&
>                           (0.0d0,0.0d0),this%rho%mat,i1,j2,this%rho%desc) 
440a148
>              enddo
442d149
<            enddo
444c151
<            call AA%dealloc()
---
>             call AA%dealloc()
449c156
<            if(this%s2print .gt. 0) call this%dump_M(i,time)
---
>            call this%dump_M(i,time)
456,457d162
<          if(this%make_Rmat) call pop%dealloc()
<          if(this%make_Rmat) call pop_new%dealloc()
499c204
<            write(11,*) i,time,Mi(1,:),dble(norm),nze
---
>            write(11,*) i,time,M(1),Mi(1,:),dble(norm),nze
501c206
<            write(12,*) i,time,Mi(2,:),dble(norm),nze
---
>            write(12,*) i,time,M(2),Mi(2,:),dble(norm),nze
503c208,215
<            write(13,*) i,time,Mi(3,:),dble(norm),nze
---
>            write(13,*) i,time,M(3),Mi(3,:),dble(norm),nze
>            flush(13)
>           else
>            write(11,*) i,time,M(1),dble(norm),nze
>            flush(11)
>            write(12,*) i,time,M(2),dble(norm),nze
>            flush(12)
>            write(13,*) i,time,M(3),dble(norm),nze
581a294
>           check=.false.
587,588c300
<            call this%U(kpt)%set(size_block,size_block,NB,MB)
<            
---
>            call this%U(kpt)%set(size_block,size_block,1,1)
590,591c302,303
<            call AA%set(size_block,size_block,NB,MB)
<            call BB%set(size_block,size_block,NB,MB)
---
>            call AA%set(size_block,size_block,1,1)
>            call BB%set(size_block,size_block,1,1)
611d322
<            check=.false.
649c360
<              call mpi_bcast(check(l+1),1,mpi_logical,l,mpi_blacs_world,err)
---
>              call mpi_bcast(check(l+1),1,mpi_logical,l,mpi_comm_world,err)
741c452
<          call this%rho%set(this%Hdim,this%Hdim,NB,MB)
---
>          call this%rho%set(this%Hdim,this%Hdim,1,1)
755c466
<                        exp(this%Ener(kpt)%v(l)/(temp*kboltz)))
---
>                        exp(this%Ener(kpt)%v(l)/(temp*kb)))
769c480
<             call mpi_allreduce(part_funct,part_funct,1,mpi_double_precision,mpi_sum,mpi_blacs_world,err)
---
>             call mpi_allreduce(part_funct,part_funct,1,mpi_double_precision,mpi_sum,mpi_comm_world,err)
831d541
< 
842c552
<          call AA%set(this%Hdim,this%Hdim,NB,MB)
---
>          call AA%set(this%Hdim,this%Hdim,1,1)
887d596
< 
896c605
<          call BB%set(this%Hdim,this%Hdim,NB,MB)
---
>          call BB%set(this%Hdim,this%Hdim,1,1)
911d619
< 
932a641,643
>             M(1)=M(1)+this%rho%mat(i,j)*conjg(this%S(1)%mat(i,j))
>             M(2)=M(2)+this%rho%mat(i,j)*conjg(this%S(2)%mat(i,j))
>             M(3)=M(3)+this%rho%mat(i,j)*conjg(this%S(3)%mat(i,j))
934a646,666
> 
>          do s=1,3
> 
>           if(mpi_id.eq.0)then
>            Mr(s)=dble(M(s))
>            do i=0,nprow-1
>             do j=0,npcol-1
>              loc_id=blacs_pnum(context,i,j)
>              if(loc_id.ne.0)then
>               info=2001
>               call mpi_recv(val,1,mpi_double_complex,loc_id,info,mpi_comm_world,mpi_status,err)
>               Mr(s)=Mr(s)+dble(val)
>              endif
>             enddo
>            enddo
>           else
>            info=2001
>            call mpi_send(M(s),1,mpi_double_complex,0,info,mpi_comm_world,err)
>           endif
> 
>          enddo
946c678
<                call mpi_recv(val,1,mpi_double_complex,loc_id,info,mpi_blacs_world,mpi_status,err)
---
>                call mpi_recv(val,1,mpi_double_complex,loc_id,info,mpi_comm_world,mpi_status,err)
953c685
<             call mpi_send(Mi(s,v),1,mpi_double_complex,0,info,mpi_blacs_world,err)
---
>             call mpi_send(Mi(s,v),1,mpi_double_complex,0,info,mpi_comm_world,err)
995c727
<           call this%H(k)%set(size_block,size_block,NB,MB)
---
>           call this%H(k)%set(size_block,size_block,1,1)
1035c767
<         integer                         :: i,j,k,info
---
>         integer                         :: i,j,info
1039,1051c771,775
<          k=0
< 
<          do j=1,this%s2print
<           if(this%print_si(j).eq.-1) k=j  
<          enddo
< 
<          if(k.eq.0)return
<          
<          if(mpi_id.eq.0) open(11,file='S_eigenval.dat')  
<          do i=1,this%Hdim          
<           call pzelget('A',' ',s_tmp(3),this%Sz(k)%mat,i,i,this%Sz(k)%desc)
<           call pzelget('A',' ',s_tmp(2),this%Sy(k)%mat,i,i,this%Sy(k)%desc)
<           call pzelget('A',' ',s_tmp(1),this%Sx(k)%mat,i,i,this%Sx(k)%desc)
---
>          if(mpi_id.eq.0) open(11,file='S_eigenval.dat')            
>          do i=1,this%Hdim
>           call pzelget('A',' ',s_tmp(3),this%S(3)%mat,i,i,this%S(3)%desc)
>           call pzelget('A',' ',s_tmp(2),this%S(2)%mat,i,i,this%S(2)%desc)
>           call pzelget('A',' ',s_tmp(1),this%S(1)%mat,i,i,this%S(1)%desc)
1066c790
<         logical,allocatable                 :: a(:),skip
---
>         logical,allocatable                 :: a(:)
1075c799
<          if(allocated(this%Sx)) return         
---
>          if(allocated(this%S)) return
1091,1093c815,817
<            call this%Sx(i)%set(this%Hdim,this%Hdim,NB,MB)
<            call this%Sy(i)%set(this%Hdim,this%Hdim,NB,MB)
<            call this%Sz(i)%set(this%Hdim,this%Hdim,NB,MB)
---
>            call this%Sx(i)%set(this%Hdim,this%Hdim,1,1)
>            call this%Sy(i)%set(this%Hdim,this%Hdim,1,1)
>            call this%Sz(i)%set(this%Hdim,this%Hdim,1,1)
1100c824,831
<                  
---
> 
>          allocate(this%S(3))
> 
>          do i=1,3
>           call this%S(i)%set(this%Hdim,this%Hdim,1,1)
>           this%S(i)%mat=(0.0d0,0.0d0)
>          enddo
>         
1106,1107c837,838
<          do ii=1,size(this%Sz(1)%mat,1)
<           do jj=1,size(this%Sz(1)%mat,2)
---
>          do ii=1,size(this%S(3)%mat,1)
>           do jj=1,size(this%S(3)%mat,2)
1110a842
>             k=1
1112c844,845
< 
---
>              this%S(3)%mat(ii,jj)=this%S(3)%mat(ii,jj)+this%basis(s,v)
>  
1117,1119d849
<               if(this%print_si(k).eq.-1)then
<                this%Sz(k)%mat(ii,jj)=this%Sz(k)%mat(ii,jj)+this%basis(s,v)
<               endif
1127,1128c857,858
<          do ii=1,size(this%Sx(1)%mat,1)
<           do jj=1,size(this%Sx(1)%mat,2)
---
>          do ii=1,size(this%S(1)%mat,1)
>           do jj=1,size(this%S(1)%mat,2)
1133,1139c863
<            do v=1,this%nspins
< 
<             skip=.true.
<             do k=1,this%s2print
<              if(this%print_si(k).eq.v) skip=.false.
<              if(this%print_si(k).eq.-1) skip=.false.
<             enddo
---
>            k=1
1141,1151c865
<             if(skip) cycle
< 
<             a=.true.
<             do k=1,this%nspins
<              if(k.ne.s .and. k.ne.t)then
<               if(ABS(this%basis(s,k)-this%basis(t,k)).gt.1.0d-8)then
<                a(k)=.false.
<                exit
<               endif
<              endif
<             enddo
---
>            do v=1,this%nspins            
1153c867
< !            call check_couple(this%nspins,this%basis(s,:),this%basis(t,:),a,v,v)
---
>             call check_couple(this%nspins,this%basis(s,:),this%basis(t,:),a,v,v)
1166a881,883
>               this%S(1)%mat(ii,jj)=this%S(1)%mat(ii,jj)+Mtmp(1)
>               this%S(2)%mat(ii,jj)=this%S(2)%mat(ii,jj)+Mtmp(2)
> 
1172,1175d888
<                if(this%print_si(k).eq.-1)then
<                 this%Sx(k)%mat(ii,jj)=this%Sx(k)%mat(ii,jj)+Mtmp(1)
<                 this%Sy(k)%mat(ii,jj)=this%Sy(k)%mat(ii,jj)+Mtmp(2)
<                endif
1189a903,905
>               this%S(1)%mat(ii,jj)=this%S(1)%mat(ii,jj)+Mtmp(1)
>               this%S(2)%mat(ii,jj)=this%S(2)%mat(ii,jj)+Mtmp(2)
> 
1195,1198d910
<                if(this%print_si(k).eq.-1)then
<                 this%Sx(k)%mat(ii,jj)=this%Sx(k)%mat(ii,jj)+Mtmp(1)
<                 this%Sy(k)%mat(ii,jj)=this%Sy(k)%mat(ii,jj)+Mtmp(2)
<                endif
1211a924,927
>           do s=1,3
>            call this%to_kbasis(this%S(s))
>           enddo
>         
1220d935
< 
1223,1226c938,945
<           do s=1,this%s2print
<            call this%to_eigenbasis(this%Sx(s))
<            call this%to_eigenbasis(this%Sy(s))
<            call this%to_eigenbasis(this%Sz(s))
---
>           do s=1,3
>            call this%to_eigenbasis(this%S(s))
>           enddo
> 
>           do k=1,this%s2print
>            call this%to_eigenbasis(this%Sx(k))
>            call this%to_eigenbasis(this%Sy(k))
>            call this%to_eigenbasis(this%Sz(k))
1231c950
<          k=this%Sx(1)%get_nze(1.0d-12)
---
>          k=this%S(1)%get_nze(1.0d-12)
1234c953
<          k=this%Sy(1)%get_nze(1.0d-12)
---
>          k=this%S(2)%get_nze(1.0d-12)
1237c956
<          k=this%Sz(1)%get_nze(1.0d-12)
---
>          k=this%S(3)%get_nze(1.0d-12)
1244d962
< 
1260c978
<         double precision :: ZERO=1.0E-8
---
>         double precision :: ZERO=1.0E-12
1264c982,984
<          a=.true.
---
>          do k=1,nspins
>           a(k)=.true.
>          enddo
1268c988,990
<            if(ABS(mapper(k)-mapper2(k)).gt.ZERO)then
---
>            if(ABS(mapper(k)-mapper2(k)).lt.ZERO)then
>             a(k)=.true.
>            else
1296,1306c1018
< !          call check_couple(this%nspins,this%basis(l,:),this%basis(l2,:),a,s1,s1)
<           a=.true.
<           do ii=1,this%nspins
<            if(ii.ne.s1 )then
<             if(ABS(this%basis(l,ii)-this%basis(l2,ii)).gt.1.0d-8)then
<              a(ii)=.false.
<              exit
<             endif
<            endif
<           enddo
< 
---
>           call check_couple(this%nspins,this%basis(l,:),this%basis(l2,:),a,s1,s1)
1327c1039
<               val=val+SH%G(i)%mat_elem(psi1,spin1,this%Bfield,this%bohr_mag(this%kind(s1)))
---
>               val=val+SH%G(i)%mat_elem(psi1,spin1,this%Bfield)
1349,1360c1061
< !            call check_couple(this%nspins,this%basis(l,:),this%basis(l2,:),a,s1,s2)
< 
<             a=.true.
<             do ii=1,this%nspins
<              if(ii.ne.s1 .and. ii.ne.s2)then
<               if(ABS(this%basis(l,ii)-this%basis(l2,ii)).gt.1.0d-8)then
<                a(ii)=.false.
<                exit
<               endif
<              endif
<             enddo
< 
---
>             call check_couple(this%nspins,this%basis(l,:),this%basis(l2,:),a,s1,s2)
1438c1139
<                 psi2(2,2)=this%basis(l2,s2)     
---
>                 psi2(2,2)=this%basis(l2,s2)
1445,1461d1145
<        
< 
< !               if( s1.eq.SH%Ddip(i)%kind(1) .and. s2.eq.SH%Ddip(i)%kind(2) ) then
< !                ii=(2*this%spin(this%kind(s2))+1)* &
< !                  (nint(this%spin(this%kind(s1))+1+this%basis(l,s1) )-1)+ &
< !                   nint(  this%spin(this%kind(s2))+1+this%basis(l,s2) )
< 
< !                jj=(2*this%spin(this%kind(s2))+1)* &
< !                   (nint(this%spin(this%kind(s1))+1+this%basis(l2,s1) )-1)+ &
< !                   nint(  this%spin(this%kind(s2))+1+this%basis(l2,s2) )
< 
< !                if(this%ntot.gt.1 .and. s2.gt.this%nspins_pr)then
< !                 val=val+SH%Ddip(i)%mat(ii,jj)*0.5d0
< !               else
< !                 val=val+SH%Ddip(i)%mat(ii,jj)
< !                endif
< !               endif
1474c1158
<         subroutine set_sph_dipolar(this,SH,SPH,ex_list)
---
>         subroutine set_dipolar(this,SH)
1478,1675c1162,1167
<         class(spins_hilbert)             :: this
<         class(SpinHamiltonian)           :: SH
<         class(SpinPhononHamiltonian)     :: SPH
<         integer                          :: i,j,s1,s2,ii,jj,v,l,m,ex,is
<         integer, allocatable             :: ex_list(:,:)
<         integer                          :: celli,cellj,Hdim1,Hdim2,Hdim12
<         double precision                 :: dist0(3)
<         double precision                 :: spin2(2),spin,psi(2),psi2(2,2)
<         integer                          :: t1,t2,rate
<         logical                          :: skip
< 
<          if(mpi_id.eq.0)then
<           call system_clock(t1,rate)        
<           write(*,*) '   Building Spin-Phonon Dipolar Network'
<           flush(6)
<          endif
< 
<          SPH%nDdip=0
< 
<          do i=1,SH%nG
<           do j=i,SH%nG
<            do ii=1,this%nspins_pr 
<            do celli=1,1!this%ntot
<             do jj=1,this%nspins_pr 
<             do cellj=1,this%ntot 
< 
<              s1=this%nspins_pr*(celli-1)+ii
<              s2=this%nspins_pr*(cellj-1)+jj
< 
<              skip=.false.
<              if(allocated(ex_list))then
<               do ex=1,size(ex_list,1)
<                if(s1.eq.ex_list(ex,1) .and. s2.eq.ex_list(ex,2) ) skip=.true.
<                if(s1.eq.ex_list(ex,2) .and. s2.eq.ex_list(ex,1) ) skip=.true.
<               enddo
<              endif
< 
<              if(s2.le.s1 .or. skip) cycle
< 
<              if(this%dist(ii,celli,jj,cellj).le.SPH%dipolar_thr)then
< 
<               if(this%kind(s1).eq.SH%G(i)%kind .and. this%kind(s2).eq.SH%G(j)%kind )then                 
<                SPH%nDdip=SPH%nDdip+1
<               endif
< 
<               if(this%kind(s1).eq.SH%G(j)%kind .and. this%kind(s2).eq.SH%G(i)%kind .and. & 
<                  SH%G(j)%kind .ne. SH%G(i)%kind  )then
<                SPH%nDdip=SPH%nDdip+1
<               endif
< 
<              endif
< 
<             enddo
<             enddo
<            enddo
<            enddo
<           enddo
<          enddo
< 
<          allocate(SPH%Ddip(SPH%nDdip))
<          allocate(SPH%Ddip_t(SPH%nDdip))
< 
<          if(mpi_id.eq.0)  &
<          write(*,*) '             Total Number of Spin-Phonon '&
<                                  'Dipolar interactions',SH%nDdip
< 
<          v=1
< 
<          do i=1,SH%nG
<           do j=i,SH%nG
<            do ii=1,this%nspins_pr 
<            do celli=1,1!this%ntot
<             do jj=1,this%nspins_pr 
<             do cellj=1,this%ntot 
< 
<              s1=this%nspins_pr*(celli-1)+ii
<              s2=this%nspins_pr*(cellj-1)+jj
< 
<              skip=.false.
<              if(allocated(ex_list))then
<               do ex=1,size(ex_list,1)
<                if(s1.eq.ex_list(ex,1) .and. s2.eq.ex_list(ex,2) ) skip=.true.
<                if(s1.eq.ex_list(ex,2) .and. s2.eq.ex_list(ex,1) ) skip=.true.
<               enddo
<              endif
< 
< 
<              if(s2.le.s1 .or. skip) cycle
< 
<              if(this%dist(ii,celli,jj,cellj).le.SPH%dipolar_thr)then
< 
<               dist0=this%dist_vec_pbc(this%x(s1,:),this%x(s2,:))  
< 
<               if(this%kind(s1).eq.SH%G(i)%kind .and. this%kind(s2).eq.SH%G(j)%kind )then
< 
<                 call SPH%Ddip_t(v)%make_dD(SH%G(i)%G,SH%G(j)%G, &
<                       this%bohr_mag(this%kind(s1)),this%bohr_mag(this%kind(s2)),dist0,this%dist(ii,celli,jj,cellj))
<                 SPH%Ddip_t(v)%nderiv=6
<                 allocate(SPH%Ddip_t(v)%map_s2a(6,2))
<                 SPH%Ddip_t(v)%map_s2a(1:3,2)=celli
<                 SPH%Ddip_t(v)%map_s2a(4:6,2)=cellj
<                 SPH%Ddip_t(v)%map_s2a(1,1)=(SPH%mapp(ii)-1)*3+1
<                 SPH%Ddip_t(v)%map_s2a(2,1)=(SPH%mapp(ii)-1)*3+2
<                 SPH%Ddip_t(v)%map_s2a(3,1)=(SPH%mapp(ii)-1)*3+3
<                 SPH%Ddip_t(v)%map_s2a(4,1)=(SPH%mapp(jj)-1)*3+1
<                 SPH%Ddip_t(v)%map_s2a(5,1)=(SPH%mapp(jj)-1)*3+2
<                 SPH%Ddip_t(v)%map_s2a(6,1)=(SPH%mapp(jj)-1)*3+3
<                 SPH%Ddip_t(v)%kind(1)=s1
<                 SPH%Ddip_t(v)%kind(2)=s2
<                  
<                 v=v+1
< 
<               endif
< 
<               if(this%kind(s1).eq.SH%G(j)%kind .and. this%kind(s2).eq.SH%G(i)%kind .and. & 
<                  SH%G(j)%kind .ne. SH%G(i)%kind  )then
< 
<                 call SPH%Ddip_t(v)%make_dD(SH%G(j)%G,SH%G(i)%G,  &
<                      this%bohr_mag(this%kind(s1)),this%bohr_mag(this%kind(s2)),dist0,this%dist(ii,celli,jj,cellj))
<                 SPH%Ddip_t(v)%nderiv=6
<                 allocate(SPH%Ddip_t(v)%map_s2a(6,2))
<                 SPH%Ddip_t(v)%map_s2a(1:3,2)=celli
<                 SPH%Ddip_t(v)%map_s2a(4:6,2)=cellj
<                 SPH%Ddip_t(v)%map_s2a(1,1)=(SPH%mapp(ii)-1)*3+1
<                 SPH%Ddip_t(v)%map_s2a(2,1)=(SPH%mapp(ii)-1)*3+2
<                 SPH%Ddip_t(v)%map_s2a(3,1)=(SPH%mapp(ii)-1)*3+3
<                 SPH%Ddip_t(v)%map_s2a(4,1)=(SPH%mapp(jj)-1)*3+1
<                 SPH%Ddip_t(v)%map_s2a(5,1)=(SPH%mapp(jj)-1)*3+2
<                 SPH%Ddip_t(v)%map_s2a(6,1)=(SPH%mapp(jj)-1)*3+3
<                 SPH%Ddip_t(v)%kind(1)=s1
<                 SPH%Ddip_t(v)%kind(2)=s2
< 
<                 v=v+1
< 
<               endif
< 
<              endif
< 
<             enddo
<             enddo
<            enddo
<            enddo
<           enddo
<          enddo
< 
< 
<          ! compute matrix representation of SH%Ddips
< 
< !         do i=1,SH%nDdip
<                 
< !          s1=SH%Ddip(i)%kind(1)
< !         s2=SH%Ddip(i)%kind(2)
<                 
< !          spin2(1)=this%spin(this%kind(s1))
< !          spin2(2)=this%spin(this%kind(s2))
< 
< !          Hdim1=(2*spin2(1)+1)
< !          Hdim2=(2*spin2(2)+1)
< !          Hdim12=Hdim1*Hdim2
< !          allocate(SH%Ddip(i)%mat(Hdim12,Hdim12))
< !          SH%Ddip(i)%mat=(0.0d0,0.0d0)
< 
< !          do l=1,Hdim12
< !           do m=1,Hdim12
< !            psi2(1,1)=-this%spin(this%kind(s1))+int((l-1)/Hdim2)
< !            psi2(1,2)=-this%spin(this%kind(s2))+mod((l-1),Hdim2)
< !            psi2(2,1)=-this%spin(this%kind(s1))+int((m-1)/Hdim2)
< !            psi2(2,2)=-this%spin(this%kind(s2))+mod((m-1),Hdim2)
< !            SH%Ddip(i)%mat(l,m)=SH%Ddip(i)%mat_elem(psi2,spin2)
< !           enddo
< !          enddo
< 
< !         enddo
< 
< 
<          if(mpi_id.eq.0)then
<           call system_clock(t2)
<           write(*,*) '       ... Done in ',real(t2-t1)/real(rate),'s'
<           flush(6)
<          endif
< 
<         return
<         end subroutine set_sph_dipolar
< 
< 
<         subroutine set_dipolar(this,SH,ex_list)
<         use spinham_class
<         use mpi_utils
<         implicit none
<         class(spins_hilbert)             :: this
<         class(SpinHamiltonian)           :: SH
<         integer                          :: i,j,s1,s2,ii,jj,v,l,m,ex,is
<         integer, allocatable             :: ex_list(:,:)
<         integer                          :: celli,cellj,Hdim1,Hdim2,Hdim12
<         double precision                 :: dist0(3)
<         double precision                 :: spin2(2),spin,psi(2),psi2(2,2)
<         integer                          :: t1,t2,rate
<         logical                          :: skip
---
>         class(spins_hilbert)       :: this
>         class(SpinHamiltonian)     :: SH
>         integer                    :: i,j,s1,s2,ii,jj,v
>         integer                    :: celli,cellj
>         double precision           :: dist0(3)
>         integer                    :: t1,t2,rate
1685,1701c1177,1185
<          do i=1,SH%nG
<           do j=i,SH%nG
<            do ii=1,this%nspins_pr 
<            do celli=1,1!this%ntot
<             do jj=1,this%nspins_pr 
<             do cellj=1,this%ntot 
< 
<              s1=this%nspins_pr*(celli-1)+ii
<              s2=this%nspins_pr*(cellj-1)+jj
< 
<              skip=.false.
<              if(allocated(ex_list))then
<               do ex=1,size(ex_list,1)
<                if(s1.eq.ex_list(ex,1) .and. s2.eq.ex_list(ex,2) ) skip=.true.
<                if(s1.eq.ex_list(ex,2) .and. s2.eq.ex_list(ex,1) ) skip=.true.
<               enddo
<              endif
---
>           do i=1,SH%nG
>            do j=i,SH%nG
>             do ii=1,this%nspins_pr 
>             do celli=1,1!this%ntot
>              do jj=1,this%nspins_pr 
>              do cellj=1,this%ntot 
> 
>               s1=this%nspins_pr*(celli-1)+ii
>               s2=this%nspins_pr*(cellj-1)+jj              
1703c1187
<              if(s2.le.s1 .or. skip) cycle
---
>               if(s2.le.s1) cycle
1705c1189
<              if(this%dist(ii,celli,jj,cellj).le.SH%dipolar_thr)then
---
>               if(this%dist(ii,celli,jj,cellj).le.SH%dipolar_thr)then
1707,1709c1191,1193
<               if(this%kind(s1).eq.SH%G(i)%kind .and. this%kind(s2).eq.SH%G(j)%kind )then                 
<                SH%nDdip=SH%nDdip+1
<               endif
---
>                if(this%kind(s1).eq.SH%G(i)%kind .and. this%kind(s2).eq.SH%G(j)%kind )then                 
>                 SH%nDdip=SH%nDdip+1
>                endif
1711,1714c1195,1198
<               if(this%kind(s1).eq.SH%G(j)%kind .and. this%kind(s2).eq.SH%G(i)%kind .and. & 
<                  SH%G(j)%kind .ne. SH%G(i)%kind  )then
<                SH%nDdip=SH%nDdip+1
<               endif
---
>                if(this%kind(s1).eq.SH%G(j)%kind .and. this%kind(s2).eq.SH%G(i)%kind .and. & 
>                   SH%G(j)%kind .ne. SH%G(i)%kind  )then
>                 SH%nDdip=SH%nDdip+1
>                endif
1716c1200
<              endif
---
>               endif
1717a1202,1203
>              enddo
>              enddo
1721d1206
<            enddo
1723d1207
<          enddo
1725,1730c1209
<          allocate(SH%Ddip(SH%nDdip))
< 
<          if(mpi_id.eq.0)  &
<          write(*,*) '             Total Number of Dipolar interactions',SH%nDdip
< 
<          v=1
---
>           allocate(SH%Ddip(SH%nDdip))
1732,1748c1211,1212
<          do i=1,SH%nG
<           do j=i,SH%nG
<            do ii=1,this%nspins_pr 
<            do celli=1,1!this%ntot
<             do jj=1,this%nspins_pr 
<             do cellj=1,this%ntot 
< 
<              s1=this%nspins_pr*(celli-1)+ii
<              s2=this%nspins_pr*(cellj-1)+jj
< 
<              skip=.false.
<              if(allocated(ex_list))then
<               do ex=1,size(ex_list,1)
<                if(s1.eq.ex_list(ex,1) .and. s2.eq.ex_list(ex,2) ) skip=.true.
<                if(s1.eq.ex_list(ex,2) .and. s2.eq.ex_list(ex,1) ) skip=.true.
<               enddo
<              endif
---
>           if(mpi_id.eq.0)  &
>           write(*,*) '             Total Number of Dipolar interactions',SH%nDdip
1749a1214
>           v=1
1751c1216,1221
<              if(s2.le.s1 .or. skip) cycle
---
>           do i=1,SH%nG
>            do j=i,SH%nG
>             do ii=1,this%nspins_pr 
>             do celli=1,1!this%ntot
>              do jj=1,this%nspins_pr 
>              do cellj=1,this%ntot 
1753c1223,1224
<              if(this%dist(ii,celli,jj,cellj).le.SH%dipolar_thr)then
---
>               s1=this%nspins_pr*(celli-1)+ii
>               s2=this%nspins_pr*(cellj-1)+jj
1755,1756c1226
<               dist0=this%dist_vec_pbc(this%x(s1,:),this%x(s2,:))  
<               write(*,*) dist0
---
>               if(s2.le.s1) cycle
1758c1228
<               if(this%kind(s1).eq.SH%G(i)%kind .and. this%kind(s2).eq.SH%G(j)%kind )then
---
>               if(this%dist(ii,celli,jj,cellj).le.SH%dipolar_thr)then
1760,1763c1230
<                call SH%Ddip(v)%make_D(SH%G(i)%G,SH%G(j)%G, &
<                     this%bohr_mag(this%kind(s1)),this%bohr_mag(this%kind(s2)),dist0,this%dist(ii,celli,jj,cellj))
<                SH%Ddip(v)%kind(1)=s1
<                SH%Ddip(v)%kind(2)=s2
---
>                dist0=this%dist_vec_pbc(this%x(s1,:),this%x(s2,:))  
1765c1232,1237
<                v=v+1
---
>                if(this%kind(s1).eq.SH%G(i)%kind .and. this%kind(s2).eq.SH%G(j)%kind )then
>                  
>                  call SH%Ddip(v)%make_D(SH%G(i)%G,SH%G(j)%G,dist0,this%dist(ii,celli,jj,cellj))
>                  SH%Ddip(v)%kind(1)=s1
>                  SH%Ddip(v)%kind(2)=s2
>                  v=v+1
1767c1239
<               endif
---
>                endif
1769,1770c1241,1242
<               if(this%kind(s1).eq.SH%G(j)%kind .and. this%kind(s2).eq.SH%G(i)%kind .and. & 
<                  SH%G(j)%kind .ne. SH%G(i)%kind  )then
---
>                if(this%kind(s1).eq.SH%G(j)%kind .and. this%kind(s2).eq.SH%G(i)%kind .and. & 
>                   SH%G(j)%kind .ne. SH%G(i)%kind  )then
1772,1775c1244,1247
<                call SH%Ddip(v)%make_D(SH%G(j)%G,SH%G(i)%G,  &
<                     this%bohr_mag(this%kind(s1)),this%bohr_mag(this%kind(s2)),dist0,this%dist(ii,celli,jj,cellj))
<                SH%Ddip(v)%kind(1)=s1
<                SH%Ddip(v)%kind(2)=s2
---
>                  call SH%Ddip(v)%make_D(SH%G(j)%G,SH%G(i)%G,dist0,this%dist(ii,celli,jj,cellj))
>                  SH%Ddip(v)%kind(1)=s1
>                  SH%Ddip(v)%kind(2)=s2
>                  v=v+1
1777c1249
<                v=v+1
---
>                endif
1781,1782c1253,1254
<              endif
< 
---
>              enddo
>              enddo
1786d1257
<            enddo
1788,1817d1258
<          enddo
< 
< 
<          ! compute matrix representation of SH%Ddips
< 
< !         do i=1,SH%nDdip
<                 
< !          s1=SH%Ddip(i)%kind(1)
< !         s2=SH%Ddip(i)%kind(2)
<                 
< !          spin2(1)=this%spin(this%kind(s1))
< !          spin2(2)=this%spin(this%kind(s2))
< 
< !          Hdim1=(2*spin2(1)+1)
< !          Hdim2=(2*spin2(2)+1)
< !          Hdim12=Hdim1*Hdim2
< !          allocate(SH%Ddip(i)%mat(Hdim12,Hdim12))
< !          SH%Ddip(i)%mat=(0.0d0,0.0d0)
< 
< !          do l=1,Hdim12
< !           do m=1,Hdim12
< !            psi2(1,1)=-this%spin(this%kind(s1))+int((l-1)/Hdim2)
< !            psi2(1,2)=-this%spin(this%kind(s2))+mod((l-1),Hdim2)
< !            psi2(2,1)=-this%spin(this%kind(s1))+int((m-1)/Hdim2)
< !            psi2(2,2)=-this%spin(this%kind(s2))+mod((m-1),Hdim2)
< !            SH%Ddip(i)%mat(l,m)=SH%Ddip(i)%mat_elem(psi2,spin2)
< !           enddo
< !          enddo
< 
< !         enddo
1855c1296
<           call this%H0(l)%set(size_block,size_block,NB,MB)  
---
>           call this%H0(l)%set(size_block,size_block,1,1)  
1858c1299
<          call AA%set(this%Hdim,this%Hdim,NB,MB)
---
>          call AA%set(this%Hdim,this%Hdim,1,1)
1871,1888d1311
< 
<          do l=1,this%Hdim
<           do l2=1,this%Hdim
<            call pzelget('A',' ',val,AA%mat,l,l2,AA%desc)
<            write(*,*) l,l2,val
<           enddo
<          enddo
< 
<          if(mpi_id.eq.0)then
<           call system_clock(t2)
<           write(*,*) '       ... Done in ',real(t2-t1)/real(rate),'s'
<           flush(6)
<          endif
<          if(mpi_id.eq.0)then
<           call system_clock(t1,rate)        
<           write(*,*) '   Rotating Hamiltonian in T invariant basis'
<           flush(6)
<          endif
1899c1322
<            call BB%set(size_block,this%Hdim,NB,MB)
---
>            call BB%set(size_block,this%Hdim,1,1)
1921,1926d1343
<          do l=1,this%ntot
<           size_block=this%kblc(l+1)-this%kblc(l)
<           jj=this%H0(l)%get_nze(1.0D-12)
<           if(mpi_id.eq.0) writE(*,*) 'H0 Sparsity:',jj,jj/dble(size_block**2)
<          enddo
< 
1947c1364
<         double precision, allocatable   :: max_dist(:,:)
---
>         double precision                :: max_dist
2007c1424
<         class(spins_hilbert)          :: this
---
>         class(spins_hilbert)            :: this
2009,2010c1426
<         integer                       :: celli,cellj,k1,k2
<         double precision,allocatable  :: max_dist(:,:)
---
>         double precision              :: max_dist
2023,2028c1439,1441
<          celli=int((si-1)/this%nspins_pr)+1
<           cellj=int((j-1)/this%nspins_pr)+1
<           k1=mod((si-1),this%nspins_pr)+1
<           k2=mod((j-1),this%nspins_pr)+1
<          if (basis_tmp(j).ne.-nint(2*this%spin(this%kind(j)))) then 
<           if(abs(this%dist(k1,celli,k2,cellj)).gt.max_dist(this%kind(j),this%kind(si))) skip_spin=.true.        
---
>          if (basis_tmp(j).ne.-nint(2*this%spin(this%kind(j))) .and. &
>              this%dist(si,1,j,1).gt.max_dist)then
>             skip_spin=.true.
2034,2040c1447,1453
<          basis_tmp(si)=-nint(2*this%spin(this%kind(si)))
<          if(si.lt.this%nspins)then
<           sj=si+1  
<           call get_Hdim(this,basis_tmp,max_ex,max_dist,v,sj)
<          else
<           v=v+1
<          endif
---
>           basis_tmp(si)=-nint(2*this%spin(this%kind(si)))
>           if(si.lt.this%nspins)then
>            sj=si+1  
>            call get_Hdim(this,basis_tmp,max_ex,max_dist,v,sj)
>           else
>            v=v+1
>           endif
2044c1457
<          if(si.lt.this%nspins)then
---
>         if(si.lt.this%nspins)then
2046d1458
<           do i=-nint(2*this%spin(this%kind(si))),nint(2*this%spin(this%kind(si))),2
2048c1460
<            basis_tmp(si)=i
---
>          do i=-nint(2*this%spin(this%kind(si))),nint(2*this%spin(this%kind(si))),2
2050,2052c1462
<            do j=si+1,this%nspins
<             basis_tmp(j)=-nint(2*this%spin(this%kind(j)))
<            enddo
---
>           basis_tmp(si)=i
2054c1464,1466
<            call check_nex(this,basis_tmp,max_ex,skip_spin)
---
>           do j=si+1,this%nspins
>            basis_tmp(j)=-nint(2*this%spin(this%kind(j)))
>           enddo
2056,2061c1468
<            if( .not. skip_spin )then
<             sj=si+1  
<             call get_Hdim(this,basis_tmp,max_ex,max_dist,v,sj)
<            else
<             v=v+1
<            endif
---
>           call check_nex(this,basis_tmp,nex)
2063c1470,1475
<           enddo
---
>           if(nex.lt.max_ex)then
>            sj=si+1  
>            call get_Hdim(this,basis_tmp,max_ex,max_dist,v,sj)
>           else
>            v=v+1
>           endif
2065c1477,1479
<          else
---
>          enddo
> 
>         else
2072c1486
<          endif
---
>         endif
2078d1491
< 
2082c1495
<         class(spins_hilbert)          :: this
---
>         class(spins_hilbert)            :: this
2084d1496
<         integer                       :: celli,cellj,k1,k2
2086c1498
<         double precision,allocatable  :: max_dist(:,:)
---
>         double precision              :: max_dist
2099,2104c1511,1513
<          celli=int((si-1)/this%nspins_pr)+1
<           cellj=int((j-1)/this%nspins_pr)+1
<           k1=mod((si-1),this%nspins_pr)+1
<           k2=mod((j-1),this%nspins_pr)+1
<          if (basis_tmp(j).ne.-nint(2*this%spin(this%kind(j)))) then 
<           if(abs(this%dist(k1,celli,k2,cellj)).gt.max_dist(this%kind(j),this%kind(si))) skip_spin=.true.        
---
>          if (basis_tmp(j).ne.-nint(2*this%spin(this%kind(j))) .and. &
>              this%dist(si,1,j,1).gt.max_dist)then
>             skip_spin=.true.
2115d1523
<            this%basis(v,:)=basis_tmp(:)/2.0d0
2131c1539
<           call check_nex(this,basis_tmp,max_ex,skip_spin)
---
>           call check_nex(this,basis_tmp,nex)
2133c1541
<           if( .not. skip_spin )then
---
>           if(nex.lt.max_ex )then
2159c1567
<         subroutine check_nex(this,basis_tmp,max_ex,skip_spin)
---
>         subroutine check_nex(this,basis_tmp,nex)
2162,2166c1570,1571
<         integer               :: i,j,k,nex,max_ex
<         integer,allocatable   :: basis_tmp(:),cas_nex(:)
<         logical               :: skip_spin
< 
<          skip_spin=.false.
---
>         integer             :: i,nex
>         integer,allocatable :: basis_tmp(:)
2168,2172d1572
<          if( allocated(this%active_space) )then            
<           allocate(cas_nex(size(this%active_space)))
<           cas_nex=0
<          endif
< 
2175,2207c1575
<           if((basis_tmp(i)+nint(2*this%spin(this%kind(i)))).ne.0) then
< 
<          ! total nex
< 
<            nex=nex+1
< 
<            if(nex.ge.max_ex)then
<             skip_spin=.true.
<             return
<            endif            
< 
<          ! compute the sub_space nex if any
< 
<            if( allocated(this%active_space) )then            
<             do j=1,size(this%active_space)
<              do k=1,size(this%active_space(j)%kind)
<             
<               if(this%active_space(j)%kind(k).eq.this%kind(i))then
<                cas_nex(j)=cas_nex(j)+1
<               endif
< 
<              enddo
< 
<              if(cas_nex(j).ge.this%active_space(j)%max_ex)then
<               skip_spin=.true.
<               return
<              endif            
< 
<             enddo                   
<            endif
< 
< 
<           endif
---
>           if((basis_tmp(i)+nint(2*this%spin(this%kind(i)))).ne.0) nex=nex+1
2210,2211d1577
<          if( allocated(cas_nex) ) deallocate(cas_nex)
< 
2214,2215c1580
<        
< 
---
>            
2228c1593
<           if(abs(this%basis(i,l)-this%basis(j,m)).gt.1.0e-4) then
---
>           if(abs(this%basis(i,l)-this%basis(j,m)).gt.1.0e-6) then
2234c1599
< 
---
>                 
2300d1664
< 
2303d1666
< 
2327d1689
< 
2329c1691
<          call mpi_allreduce(nelem_tot,nelem_tot,1,mpi_integer,mpi_sum,mpi_blacs_world,err)
---
>          call mpi_allreduce(nelem_tot,nelem_tot,1,mpi_integer,mpi_sum,mpi_comm_world,err)
2336c1698
<           call mpi_bcast(Tmat%AI(i+1),1,mpi_integer,proc_grid(i),mpi_blacs_world,err)
---
>           call mpi_bcast(Tmat%AI(i+1),1,mpi_integer,proc_grid(i),mpi_comm_world,err)
2357,2358c1719,1720
<           call mpi_allreduce(Tmat%AJ(i),Tmat%AJ(i),1,mpi_integer,mpi_sum,mpi_blacs_world,err)
<           call mpi_allreduce(Tmat%A(i),Tmat%A(i),1,mpi_double_complex,mpi_sum,mpi_blacs_world,err)
---
>           call mpi_allreduce(Tmat%AJ(i),Tmat%AJ(i),1,mpi_integer,mpi_sum,mpi_comm_world,err)
>           call mpi_allreduce(Tmat%A(i),Tmat%A(i),1,mpi_double_complex,mpi_sum,mpi_comm_world,err)
2462c1824
< 
---
>  
2464c1826
<           call mpi_allreduce(nelem_tot,nelem_tot,1,mpi_integer,mpi_sum,mpi_blacs_world,err)
---
>           call mpi_allreduce(nelem_tot,nelem_tot,1,mpi_integer,mpi_sum,mpi_comm_world,err)
2471c1833
<            call mpi_bcast(Tmat%AI(i+1),1,mpi_integer,proc_grid(i),mpi_blacs_world,err)
---
>            call mpi_bcast(Tmat%AI(i+1),1,mpi_integer,proc_grid(i),mpi_comm_world,err)
2492,2493c1854,1855
<           call mpi_allreduce(Tmat%AJ(i),Tmat%AJ(i),1,mpi_integer,mpi_sum,mpi_blacs_world,err)          
<           call mpi_allreduce(Tmat%A(i),Tmat%A(i),1,mpi_double_complex,mpi_sum,mpi_blacs_world,err)
---
>           call mpi_allreduce(Tmat%AJ(i),Tmat%AJ(i),1,mpi_integer,mpi_sum,mpi_comm_world,err)
>           call mpi_allreduce(Tmat%A(i),Tmat%A(i),1,mpi_double_complex,mpi_sum,mpi_comm_world,err)
2654d2015
< 
2657c2018
<          call this%kbasis%set(this%Hdim,this%Hdim,NB,MB)
---
>          call this%kbasis%set(this%Hdim,this%Hdim,1,1)
2673,2675d2033
< 
<          jj=this%kbasis%get_nze(1.0D-12)
<          if(mpi_id.eq.0) writE(*,*) 'Kbasis Sparsity:',jj,jj/dble(this%Hdim**2)
2697c2055,2057
<         subroutine make_rot(this,pulse)
---
> 
> 
>         subroutine make_rot(this,alpha,beta,gamma,rot)
2702,2703d2061
<         use units_parms
<         use exponential_class
2706,2713c2064,2067
<         type(general_pulse),allocatable :: pulse(:)
<         integer                         :: i,ii,k,indxl2g
<         complex(8)                      :: angle
<         type(dist_cmplx_mat)            :: Sn
<         integer                         :: spin
< 
< 
<          do i=1,size(pulse)
---
>         integer                         :: ii,jj,i,j,k,l,v,desca(9),indxl2g,kpt
>         double precision, allocatable   :: alpha(:),beta(:),gamma(:)
>         complex(8),allocatable          :: rot_i(:,:),AA(:,:)
>         type(dist_cmplx_mat)            :: rot
2714a2069
>          if(allocated(rot%mat)) call rot%dealloc()
2716,2717c2071
<           call Sn%set(this%Hdim,this%Hdim,NB,MB)
<           Sn%mat=(0.0d0,0.0d0)
---
>          call rot%set(this%Hdim,this%Hdim,1,1)
2719,2721c2073,2074
<           if(allocated(pulse(i)%rot%mat)) call pulse(i)%rot%dealloc()
<           call pulse(i)%rot%set(this%Hdim,this%Hdim,NB,MB)
<           pulse(i)%rot%mat=(0.0d0,0.0d0)
---
>          do ii=1,size(rot%mat,1)
>           do jj=1,size(rot%mat,2)
2723,2728c2076,2077
<           do k=1,this%s2print
<            if(this%print_si(k).eq.pulse(i)%spin)then
<             spin=k
<             exit
<            endif
<           enddo
---
>            i=indxl2g(ii,1,myrow,0,nprow)
>            j=indxl2g(jj,1,mycol,0,npcol)
2730,2736c2079
<           pulse(i)%n=pulse(i)%n/  &
<                 sqrt(pulse(i)%n(1)**2+pulse(i)%n(2)**2+pulse(i)%n(3)**2)
< 
< 
<           Sn%mat=this%Sx(spin)%mat*pulse(i)%n(1)+     &
<                  this%Sy(spin)%mat*pulse(i)%n(2)+     &
<                  this%Sz(spin)%mat*pulse(i)%n(3)
---
>            do v=1,this%nspins
2738c2081
<           angle=cmplx(pulse(i)%beta,0.0d0,8)
---
>             call rot_wig(this%spin(this%kind(v)),alpha(v),beta(v),gamma(v),rot_i)
2740,2741c2083,2092
<           call exp_taylor(this%Hdim,Sn,pulse(i)%rot,angle,100) 
<           call Sn%dealloc()
---
>             k=nint(  this%spin(this%kind(v))+1+this%basis(i,v) )
>             l=nint(  this%spin(this%kind(v))+1+this%basis(j,v) )
>             if(v.eq.1)then
>              rot%mat(ii,jj)=rot_i(k,l)
>             else
>              rot%mat(ii,jj)=rot%mat(ii,jj)*rot_i(k,l)
>             endif
>            enddo
>           enddo
>          enddo
2743,2744d2093
<           ii=pulse(i)%rot%get_nze(1.0d-12)
<           if(mpi_id.eq.0) write(*,*) 'Pulse Sparsity:',ii,ii/dble(this%Hdim**2)
2746c2095,2098
<          enddo
---
>          if(this%ntot.gt.1) call this%to_kbasis(rot)
>          if(this%make_Heig)then
>           call this%to_eigenbasis(rot) 
>          endif
2751c2103,2104
<         subroutine rot_rho(this,pulse)
---
> 
>         subroutine rot_rho(this,transf)
2757,2759c2110,2121
<         type(general_pulse),allocatable  :: pulse(:)
<         integer                          :: si,i,j,ii,jj,indxl2g
<         type(dist_cmplx_mat)             :: AA,BB,newrho
---
>         type(general_pulse),allocatable  :: transf(:)
>         double precision                 :: weight_old,weight_new
>         integer                          :: si,i,j
>         double precision, allocatable    :: alpha(:),beta(:),gamma(:)
>         type(dist_cmplx_mat)             :: rot,AA,BB,newrho
> 
>          call newrho%set(this%Hdim,this%Hdim,1,1) 
>          call AA%set(this%Hdim,this%Hdim,1,1) 
> 
>          allocate(alpha(this%nspins))
>          allocate(beta(this%nspins))
>          allocate(gamma(this%nspins))
2761,2762d2122
<          call newrho%set(this%Hdim,this%Hdim,NB,MB)          
<          call AA%set(this%Hdim,this%Hdim,NB,MB) 
2765c2125
<          do i=1,size(pulse)
---
>          do i=1,size(transf)
2769c2129,2142
<           if(pulse(i)%sx .and. (.not. pulse(i)%dx) )then
---
>           alpha=0.0d0
>           beta=0.0d0
>           gamma=0.0d0
> 
>           do j=1,size(transf(i)%spin)           
>            si=transf(i)%spin(j)
>            alpha(si)=transf(i)%alpha(j)
>            beta(si)=transf(i)%beta(j)           
>            gamma(si)=transf(i)%gamma(j)
>           enddo
> 
>           call make_rot(this,alpha,beta,gamma,rot)
> 
>           if(transf(i)%sx .and. (.not. transf(i)%dx) )then
2772c2145
<                         (1.0d0,0.0d0),pulse(i)%rot%mat,1,1,pulse(i)%rot%desc,this%rho%mat,&
---
>                         (1.0d0,0.0d0),rot%mat,1,1,rot%desc,this%rho%mat,&
2778c2151
<           if( pulse(i)%dx .and. (.not. pulse(i)%sx) )then
---
>           if(transf(i)%dx .and. (.not. transf(i)%sx) )then
2781c2154
<                         (1.0d0,0.0d0),this%rho,1,1,this%rho%desc,pulse(i)%rot%mat,1,1,pulse(i)%rot%desc,&
---
>                         (1.0d0,0.0d0),this%rho,1,1,this%rho%desc,rot%mat,1,1,rot%desc,&
2787c2160
<           if( pulse(i)%dx .and. pulse(i)%sx )then
---
>           if(transf(i)%dx .and. transf(i)%sx )then
2789c2162
<            call BB%set(this%Hdim,this%Hdim,NB,MB)
---
>            call BB%set(this%Hdim,this%Hdim,1,1)
2792c2165
<                          (1.0d0,0.0d0),pulse(i)%rot%mat,1,1,pulse(i)%rot%desc,this%rho%mat,&
---
>                          (1.0d0,0.0d0),rot%mat,1,1,rot%desc,this%rho%mat,&
2796c2169
<                          (1.0d0,0.0d0),BB%mat,1,1,BB%desc,pulse(i)%rot%mat,1,1,pulse(i)%rot%desc,&
---
>                          (1.0d0,0.0d0),BB%mat,1,1,BB%desc,rot%mat,1,1,rot%desc,&
2803c2176
<           newrho%mat=newrho%mat+pulse(i)%weight*AA%mat
---
>           newrho%mat=newrho%mat+transf(i)%weight*AA%mat
2810a2184,2186
>          deallocate(alpha)
>          deallocate(beta)
>          deallocate(gamma)
